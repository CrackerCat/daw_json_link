// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.

/*
    This is a derivative work
*/
#pragma once

#include "common.hpp"

#if defined( DAW_JSON_RYU_HAS_64_BIT_INTRINSICS )
#include <intrin.h>
#endif
#include <cstdint>

namespace ryu::detail {

#if defined( DAW_JSON_RYU_HAS_64_BIT_INTRINSICS )

	inline uint64_t umul128( std::uint64_t const a, std::uint64_t const b,
	                         uint64_t *const productHi ) {
		return _umul128( a, b, productHi );
	}

	inline uint64_t shiftright128( std::uint64_t const lo, std::uint64_t const hi,
	                               std::uint32_t const dist ) {
		// For the __shiftright128 intrinsic, the shift value is always
		// modulo 64.
		// In the current implementation of the double-precision version
		// of Ryu, the shift value is always < 64. (In the case
		// RYU_OPTIMIZE_SIZE == 0, the shift value is in the range [49, 58].
		// Otherwise in the range [2, 59].)
		// Check this here in case a future change requires larger shift
		// values. In this case this function needs to be adjusted.
		assert( dist < 64 );
		return __shiftright128( lo, hi, (unsigned char)dist );
	}

#else // defined(HAS_64_BIT_INTRINSICS)

	inline uint64_t umul128( std::uint64_t const a, std::uint64_t const b,
	                         uint64_t *const productHi ) {
		// The casts here help MSVC to avoid calls to the __allmul library
		// function.
		std::uint32_t const aLo = static_cast<uint32_t>( a );
		std::uint32_t const aHi = static_cast<uint32_t>( a >> 32 );
		std::uint32_t const bLo = static_cast<uint32_t>( b );
		std::uint32_t const bHi = static_cast<uint32_t>( b >> 32 );

		std::uint64_t const b00 = static_cast<uint64_t>( aLo ) * bLo;
		std::uint64_t const b01 = static_cast<uint64_t>( aLo ) * bHi;
		std::uint64_t const b10 = static_cast<uint64_t>( aHi ) * bLo;
		std::uint64_t const b11 = static_cast<uint64_t>( aHi ) * bHi;

		std::uint32_t const b00Lo = static_cast<uint32_t>( b00 );
		std::uint32_t const b00Hi = static_cast<uint32_t>( b00 >> 32 );

		std::uint64_t const mid1 = b10 + b00Hi;
		std::uint32_t const mid1Lo = static_cast<uint32_t>( mid1 );
		std::uint32_t const mid1Hi = static_cast<uint32_t>( mid1 >> 32 );

		std::uint64_t const mid2 = b01 + mid1Lo;
		std::uint32_t const mid2Lo = static_cast<uint32_t>( mid2 );
		std::uint32_t const mid2Hi = static_cast<uint32_t>( mid2 >> 32 );

		std::uint64_t const pHi = b11 + mid1Hi + mid2Hi;
		std::uint64_t const pLo = ( static_cast<uint64_t>( mid2Lo ) << 32 ) | b00Lo;

		*productHi = pHi;
		return pLo;
	}

	inline uint64_t shiftright128( std::uint64_t const lo, std::uint64_t const hi,
	                               std::uint32_t const dist ) {
		// We don't need to handle the case dist >= 64 here (see above).
		assert( dist < 64 );
#if defined( RYU_OPTIMIZE_SIZE ) || !defined( RYU_32_BIT_PLATFORM )
		assert( dist > 0 );
		return ( hi << ( 64 - dist ) ) | ( lo >> dist );
#else
		// Avoid a 64-bit shift by taking advantage of the range of shift values.
		assert( dist >= 32 );
		return ( hi << ( 64 - dist ) ) |
		       ( ( uint32_t )( lo >> 32 ) >> ( dist - 32 ) );
#endif
	}

#endif // defined(HAS_64_BIT_INTRINSICS)

#ifdef RYU_32_BIT_PLATFORM

	// Returns the high 64 bits of the 128-bit product of a and b.
	inline constexpr uint64_t umulh( std::uint64_t const a,
	                                 std::uint64_t const b ) {
		// Reuse the umul128 implementation.
		// Optimizers will likely eliminate the instructions used to compute the
		// low part of the product.
		uint64_t hi;
		umul128( a, b, &hi );
		return hi;
	}

	// On 32-bit platforms, compilers typically generate calls to library
	// functions for 64-bit divisions, even if the divisor is a constant.
	//
	// E.g.:
	// https://bugs.llvm.org/show_bug.cgi?id=37932
	// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=17958
	// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37443
	//
	// The functions here perform division-by-constant using multiplications
	// in the same way as 64-bit compilers would do.
	//
	// NB:
	// The multipliers and shift values are the ones generated by clang x64
	// for expressions like x/5, x/10, etc.

	inline constexpr uint64_t div5( std::uint64_t const x ) {
		return umulh( x, 0xCCCCCCCCCCCCCCCDu ) >> 2;
	}

	inline constexpr uint64_t div10( std::uint64_t const x ) {
		return umulh( x, 0xCCCCCCCCCCCCCCCDu ) >> 3;
	}

	inline constexpr uint64_t div100( std::uint64_t const x ) {
		return umulh( x >> 2, 0x28F5C28F5C28F5C3u ) >> 2;
	}

	inline constexpr uint64_t div1e8( std::uint64_t const x ) {
		return umulh( x, 0xABCC77118461CEFDu ) >> 26;
	}

	inline constexpr uint64_t div1e9( std::uint64_t const x ) {
		return umulh( x >> 9, 0x44B82FA09B5A53u ) >> 11;
	}

	inline constexpr uint32_t mod1e9( std::uint64_t const x ) {
		// Avoid 64-bit math as much as possible.
		// Returning (uint32_t) (x - 1000000000 * div1e9(x)) would
		// perform 32x64-bit multiplication and 64-bit subtraction.
		// x and 1000000000 * div1e9(x) are guaranteed to differ by
		// less than 10^9, so their highest 32 bits must be identical,
		// so we can truncate both sides to uint32_t before subtracting.
		// We can also simplify (uint32_t) (1000000000 * div1e9(x)).
		// We can truncate before multiplying instead of after, as multiplying
		// the highest 32 bits of div1e9(x) can't affect the lowest 32 bits.
		return ( (uint32_t)x ) - 1000000000 * ( (uint32_t)div1e9( x ) );
	}

#else // RYU_32_BIT_PLATFORM

	inline constexpr uint64_t div5( std::uint64_t const x ) {
		return x / 5;
	}

	inline constexpr uint64_t div10( std::uint64_t const x ) {
		return x / 10;
	}

	inline constexpr uint64_t div100( std::uint64_t const x ) {
		return x / 100;
	}

	inline constexpr uint64_t div1e8( std::uint64_t const x ) {
		return x / 100000000;
	}

	inline constexpr uint64_t div1e9( std::uint64_t const x ) {
		return x / 1000000000;
	}

	inline constexpr uint32_t mod1e9( std::uint64_t const x ) {
		return static_cast<uint32_t>( x - 1000000000 * div1e9( x ) );
	}

#endif // RYU_32_BIT_PLATFORM

	inline uint32_t pow5Factor( uint64_t value ) {
		uint32_t count = 0;
		for( ;; ) {
			assert( value != 0 );
			std::uint64_t const q = div5( value );
			std::uint32_t const r =
			  ( static_cast<uint32_t>( value ) ) - 5 * ( static_cast<uint32_t>( q ) );
			if( r != 0 ) {
				break;
			}
			value = q;
			++count;
		}
		return count;
	}

	// Returns true if value is divisible by 5^p.
	inline bool multipleOfPowerOf5( std::uint64_t const value,
	                                std::uint32_t const p ) {
		// I tried a case distinction on p, but there was no performance
		// difference.
		return pow5Factor( value ) >= p;
	}

	// Returns true if value is divisible by 2^p.
	inline bool multipleOfPowerOf2( std::uint64_t const value,
	                                std::uint32_t const p ) {
		assert( value != 0 );
		// return __builtin_ctzll(value) >= p;
		return ( value & ( ( 1ull << p ) - 1 ) ) == 0;
	}

} // namespace ryu::detail
